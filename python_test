#!/usr/bin/env python
from OpenGL.GLUT import *
from OpenGL.GL import *
import gjslib_c

def init_opengl():
        glutInit(sys.argv)
        glutInitDisplayMode(GLUT_3_2_CORE_PROFILE |GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
        glutInitWindowSize(64,64)
        glutCreateWindow("self.window_title")

print "init opengl"        
init_opengl()
#a = gjslib_c.texture(filename='images/IMG_2162.JPG')

print "Create textures"
tb = []
size = 1024
for i in range(12):
        tb.append(gjslib_c.texture(width=size, height=size))
        pass
print tb[0].width, tb[0].height


#b = gjslib_c.filter(filter="glsl:yuv_from_rgb(1,3)&-DINTENSITY_YSCALE=(3456.0/5184.0)&-DINTENSITY_XOFS=0.0&-DINTENSITY_XSCALE=1.0&-DINTENSITY_YOFS=0.0")
#b.define("INTENSITY_YSCALE","3.0")
#b.define("INTENSITY_YSCALE",remove=1)
#b.compile()

def save_as_png(texture, filename):
        b = gjslib_c.filter(filter="save:%s(0)"%filename)
        b.textures([texture])
        b.compile()
        b.execute()
        pass

#save_as_png(tb[0], "test_black.png")

def alu_test(ops):
    for (ts, op, save_filename) in ops:
            b = gjslib_c.filter(filter="glsl:alu_buffers(0,0,0)")
            b.define("OP",op)
            b.compile()
            b.textures( [tb[i] for i in ts] )
            b.execute()
            save_as_png(tb[ts[-1]],save_filename)
            pass
    pass

class c_filter(object):
    filter_text = 'glsl:yuv_from_rgb(1,2)'
    defines = {}
    parameters = {}
    def __init__(self, extra_parameters={}, extra_defines={}):
        self.f = gjslib_c.filter(filter=self.filter_text)
        for u in extra_parameters:
            self.f.parameter(u,extra_parameters[u])
        for u in self.parameters:
            if u not in extra_parameters:    
                self.f.parameter(u,self.parameters[u])
        for d in extra_defines:
            self.f.define(d,str(extra_defines[d]))
            pass
        for d in self.defines:
            if d not in extra_defines:
                self.f.define(d,str(self.defines[d]))
                pass
            pass
        self.f.compile()
        pass
    def set_parameters(self, parameters={}):
        for p in parameters:
            self.f.parameter(p,parameters[p])
            pass
        pass
    def execute(self,textures):
        self.f.textures(textures)
        self.f.execute()
        pass
    pass

class c_alu_filter(c_filter):
    filter_text = 'glsl:alu_buffers(0,0,0)'

class c_yuv_from_rgb(c_filter):
    filter_text = 'glsl:yuv_from_rgb(1,2)'

if False:
    to_rgb = c_yuv_from_rgb(extra_parameters={"xsc":2.0,"ysc":2.0,"xc":1.0,"yc":1.0},
                            extra_defines={"EXTRA_VERTEX_UNIFORMS":"uniform float xsc, ysc, xc, yc;",
                                           "GL_POSITION":"vec4(ysc*y+yc,xsc*x+xc,0,1)",
                                           })
    img = gjslib_c.texture(filename='images/IMG_2162.JPG')
    to_rgb.f.parameter("ysc",4.0)
    to_rgb.f.parameter("xsc",4.0)
    to_rgb.f.parameter("yc",-2.0)
    to_rgb.f.parameter("xc",-2.0)
    to_rgb.execute((img,tb[4]))
    save_as_png(tb[4],"img_rgb2.png")
    die

class c_gauss_filter_y(c_filter):
    filter_text = 'glsl:gauss(1,2)'
    defines = {"X_NOT_Y":"false", "NUM_WEIGHTS":"9", "WEIGHTS":"gauss_offset_weights9"}

class c_gauss_filter_x(c_filter):
    filter_text = 'glsl:gauss(1,2)'
    defines = {"X_NOT_Y":"true", "NUM_WEIGHTS":"9", "WEIGHTS":"gauss_offset_weights9"}
        
class c_sobel_filter(c_filter):
    filter_text = 'glsl:convolve_2d(1,2)'
    defines = {"NUM_WEIGHTS":"9", "OFFSET_WEIGHTS":"sobel_weights"}

class c_harris_filter(c_filter):
    filter_text = 'glsl:harris(1,2)'
    defines = {"NUM_OFFSETS":"25", "OFFSETS":"offsets_2d_25"}

class c_circle_dft_filter(c_filter):
    filter_text = "glsl:circle_dft(2,4)"
    defines = { "NUM_CIRCLE_STEPS":"8", 
                "DFT_CIRCLE_RADIUS":"8",
                "CIRCLE_COMPONENT":"r" }

class c_circle_dft_diff_filter(c_filter):
    filter_text = "glsl:circle_dft_diff(2,4,5)"
    parameters = {"uv_base_x":0.0, "uv_base_y":0.0}

class c_circle_dft_diff_combine_filter(c_filter):
    filter_text = "glsl:circle_dft_diff_combine(1,2,3,4,0)"
    defines = {"DISCRETE_CIRCLE_OFS":"discrete_circle_offsets_4_32",
               "NUM_OFFSETS":32}

class c_find_filter(c_filter):
    filter_text = "find:a(1)"

class c_windowed_equalization_filter(c_filter):
    filter_text = 'glsl:windowed_equalization(2,4)'
    defines = {"NUM_OFFSETS":81, "OFFSETS":"offsets_2d_81"}

if False:
    print "ALU tests"

    alu_test( [ ((2,2,0), "0.5", "test_constant_50.png"),
                ((2,2,1), "0.8", "test_constant_80.png"),
                ((0,1,2), "src_a*src_b", "test_constant_40.png"),
                ] )

    alu_test( [ ((2,2,0), "(x*y)",    "test_xy.png"),
                ((2,2,1), "(1-x)*y",  "test_x1y.png"),
                ((0,1,2), "(1-4*src_a*src_b)", "test_xymult.png"),
                ] )

    alu_test( [ ((2,2,0), "abs(sin(200*x*y)*sin(200*(1-x)*y))",    "test_sin_xy.png"),
                ] )


if False:
    print "Gauss filter and find test"
    gfx = c_gauss_filter_x()
    gfy = c_gauss_filter_y()
    gfx.execute((tb[0],tb[1]))
    gfy.execute((tb[1],tb[2]))
    save_as_png(tb[2],"test_gauss_sin_xy.png")

    alu_test( [ ((0,2,3),"30*abs(src_a-src_b)","test_gauss_sin_xy_diff.png"),
                ] )

    circle_dft = c_circle_dft_filter(extra_defines={"SINGLE_COMPONENT":4, "COMPONENT_SCALE":4})
    circle_dft.execute((tb[2],tb[3]))
    save_as_png(tb[3],"test_gauss_sin_xy_dft.png")

    f = gjslib_c.filter(filter='find:a(10)')
    f.compile()
    f.textures((tb[3],))
    f.parameter("minimum",0.87)
    f.execute()
    print f.num_points
    print f.points

if False:
    print "DFT images"

    img = gjslib_c.texture(filename='images/IMG_2162.JPG')
    to_rgb = c_yuv_from_rgb(extra_defines={"INTENSITY_XSCALE":"%f"%(img.height/float(img.width)),
                                           "INTENSITY_YSCALE":"1.0",
                                           "INTENSITY_YOFS":"0.0",
                                           "INTENSITY_XOFS":"0.0",})
    to_rgb.execute((img,tb[4]))
    save_as_png(tb[4],"img_rgb.png")

    for (i,sc) in [(0,1), (1,6), (2,5), (3,3.5), (4,2), (5,2), (6,2)]:
        if False:
                circle_dft = c_circle_dft_filter(extra_defines={"DFT_CIRCLE_RADIUS":4+4*i,
                                                                "SINGLE_COMPONENT":2,
                                                                "COMPONENT_SCALE":4})
                pass
        else:
                circle_dft = c_circle_dft_filter(extra_defines={"DFT_CIRCLE_RADIUS":8,
                                                        "SINGLE_COMPONENT":i,
                                                        "COMPONENT_SCALE":sc})
                pass
        circle_dft.execute((tb[4],tb[5]))
        save_as_png(tb[5],"img_dft_%d.png"%i)
    pass

if True:
    print "Diff images"

    imgs = ( gjslib_c.texture(filename='images/IMG_1900.JPG'),
             gjslib_c.texture(filename='images/IMG_1901_r10.JPG') )

    to_rgb = c_yuv_from_rgb(extra_parameters={"xsc":2.0,"ysc":2.0,"xc":1.0,"yc":1.0},
                            extra_defines={"EXTRA_VERTEX_UNIFORMS":"uniform float xsc, ysc, xc, yc;",
                                           "GL_POSITION":"vec4(xsc*x+xc,ysc*y+yc,0,1)",
                                           })
    copy_img = c_alu_filter(extra_defines={"OP":"src_a"})
    equalize = c_windowed_equalization_filter()
    harris = c_harris_filter()
    find_corners = c_find_filter(extra_parameters={"min_distance":10.0, "max_elements":20})
    find_matches = c_find_filter(extra_parameters={"min_distance":2.5, "minimum":0.1, "max_elements":100})
    circle_dft = c_circle_dft_filter(extra_defines={"DFT_CIRCLE_RADIUS":8,
                                                    "CIRCLE_COMPONENT":"r",
                                                    })
    circle_dft_diff         = c_circle_dft_diff_filter()
    circle_dft_diff_combine = c_circle_dft_diff_combine_filter()

    ar = float(imgs[0].width)/imgs[0].height
    to_rgb.set_parameters( {"ysc":2.0, "yc":-1.0, "xsc":2.0*ar, "xc":-1.0-ar*0} )
    to_rgb.execute((imgs[0],tb[0]))
    to_rgb.execute((imgs[1],tb[1]))
    harris.execute( (tb[0],tb[4]) )

    if False: # do windowed equalization to remove brightness and contrastiness dependence - with loss of information
        copy_img.execute((tb[0],tb[0],tb[2]))
        equalize.execute((tb[2],tb[0]))
        copy_img.execute((tb[1],tb[1],tb[2]))
        equalize.execute((tb[2],tb[1]))
        pass
    circle_dft.execute((tb[0],tb[2]))
    circle_dft.execute((tb[1],tb[3]))
    find_corners.execute( (tb[4],) )

    print find_corners.f.num_points
    print find_corners.f.points[:10]

    pt = find_corners.f.points[0]
    xy = (pt[0],pt[1])
    for i, dxy in [(0,(4,0)), (1,(0,4)), (2,(-4,0)), (3,(0,-4))]:
        circle_dft_diff.set_parameters( {"uv_base_x":xy[0]+dxy[0], "uv_base_y":xy[1]+dxy[1]} )
        circle_dft_diff.execute( (tb[2], tb[3], tb[5+i]) )
        pass
    circle_dft_diff_combine.execute( (tb[5], tb[6], tb[7], tb[8], tb[9]) )
    find_matches.execute( (tb[9],) )
    for i in range(10):
        save_as_png(tb[i],"img_dft_%d.png"%i)

    pass

if True:
    lens_projection = gjslib_c.lens_projection
    quaternion      = gjslib_c.quaternion

    a = quaternion.roll(60, degrees=1)
    print a.rotate_vector((1,0,3))
    print a.rotate_vector((0,1,3))

    lp_20 = lens_projection(frame_width=36.0, focal_length=20.0, lens_type="rectilinear")
    print quaternion.roll(60,degrees=1)
    print quaternion().identity()
    a = quaternion()
    b = quaternion()
    c = quaternion(r=1.0)
    print c
    c = quaternion(r=1, i=2, j=3, k=4) * quaternion(i=1)* quaternion(j=1)* quaternion(k=1)
    print c

    a.scale(2)
    print a.rijk
    a.lookat((1,2,3),(4,5,4))
    b.lookat((1,0,0),(0,1,0))
    print "a", a
    print "b", b
    print "~a", ~a
    print abs(a)
    a.from_rotation((1,1,0),60.0,degrees=1)
    print a
    a.from_euler(pitch=60.0,degrees=1)
    lp_20.orient(a)
    print lp_20
    print "orientation of 0,0",lp_20.orientation_of_xy((0,0))
    print "x,y of orientation of a",lp_20.xy_of_orientation(a)
    a.from_rotation((1,1,0),60.0,degrees=1)
    lp_20.orient(a)
    print lp_20
    print "orientation of 0,0",lp_20.orientation_of_xy((0,0))
    print "x,y of orientation of a",lp_20.xy_of_orientation(a)
    print a
    print lp_20.orientation
    a.scale(2)
    print a
    print lp_20.orientation
